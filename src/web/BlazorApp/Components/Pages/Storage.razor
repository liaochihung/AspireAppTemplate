@page "/storage"
@using AspireAppTemplate.Shared
@using System.Net.Http.Headers
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Authorization
@inject StorageApiClient StorageClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@attribute [Authorize]

<PageTitle>File Manager | Aspire App</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-8">
    <MudText Typo="Typo.h3" GutterBottom="true">File Manager</MudText>
    
    <MudGrid>
        <!-- Left Sidebar: Tree View -->
        <MudItem xs="12" md="3">
            <MudPaper Elevation="2" Class="pa-4" Style="height: 100%; min-height: 500px;">
                <MudText Typo="Typo.h6" Class="mb-4">Explorer</MudText>
                @if (_loading)
                {
                    <MudSkeleton SkeletonType="SkeletonType.Text" Count="5" />
                }
                else
                {
                    <MudTreeView T="FileTreeItem" Items="@_treeItems" Hover="true" Width="100%">
                        <ItemTemplate>
                            <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value"
                                             Icon="@context.Icon"
                                             IconColor="@(context.Value?.IsFolder == true ? Color.Warning : Color.Default)"
                                             Text="@context.Text"
                                             OnClick="@(() => OnTreeItemClick(context))" />
                        </ItemTemplate>
                    </MudTreeView>
                }
            </MudPaper>
        </MudItem>

        <!-- Right Content: Preview / Gallery -->
        <MudItem xs="12" md="9">
            <MudPaper Elevation="2" Class="pa-4 mb-4">
                <!-- Toolbar -->
                <MudToolBar Dense="true" Class="px-0">
                    <div class="d-flex align-center">
                        <MudLink Typo="Typo.h6" OnClick="@(() => OnBreadcrumbClick(null))" Underline="Underline.Hover" Color="Color.Inherit">Root</MudLink>
                        @if (_breadcrumbLinks.Any())
                        {
                            @foreach (var breadcrumb in _breadcrumbLinks)
                            {
                                <MudIcon Icon="@Icons.Material.Filled.ChevronRight" Class="mx-2" Color="Color.Default" Size="Size.Small" />
                                <MudLink Typo="Typo.h6" OnClick="@(() => OnBreadcrumbClick(breadcrumb.Path))" Underline="Underline.Hover" Color="Color.Inherit">@breadcrumb.Name</MudLink>
                            }
                        }
                    </div>
                    <MudSpacer />
                    <MudTooltip Text="New Folder">
                        <MudIconButton Icon="@Icons.Material.Filled.CreateNewFolder" OnClick="CreateFolder" Color="Color.Default" />
                    </MudTooltip>
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="LoadFiles" Color="Color.Default" />
                </MudToolBar>
            </MudPaper>

            <!-- Upload Zone -->
            <MudPaper Class="mb-4" Elevation="0" Style="position: relative; width: 100%; height: 150px;">
                <MudFileUpload T="IBrowserFile" FilesChanged="UploadFiles" Hidden="false" Style="width: 100%; height: 100%;" InputClass="absolute" InputStyle="width: 100%; height: 100%; overflow: hidden; position: absolute; top: 0; left: 0; z-index: 20; opacity: 0;">
                    <ActivatorContent>
                         <MudPaper Class="d-flex align-center justify-center pa-6 border-dashed mud-border-primary" Elevation="0" Style="border: 2px dashed var(--mud-palette-primary); background-color: rgba(var(--mud-palette-primary-rgb), 0.05); width: 100%; height: 100%;">
                            <div class="d-flex flex-column align-center">
                                <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Large" Color="Color.Primary" Class="mb-2" />
                                <MudText Typo="Typo.h6" Color="Color.Primary">Drag & Drop Files Here</MudText>
                                <MudText Typo="Typo.caption" Color="Color.Secondary">or click to browse</MudText>
                            </div>
                        </MudPaper>
                    </ActivatorContent>
                </MudFileUpload>
            </MudPaper>

            <!-- File Content / Gallery -->
            <MudPaper Elevation="2" Class="pa-4 d-flex flex-column" Style="min-height: 600px;">
                @if (_selectedItem != null && !_selectedItem.IsFolder)
                {
                    <!-- Single File Preview -->
                    <div class="d-flex align-center mb-4">
                        <MudIcon Icon="@Icons.Material.Filled.Description" Class="mr-2" />
                        <MudText Typo="Typo.h5">@_selectedItem.Name</MudText>
                        <MudSpacer />
                        <MudText Typo="Typo.caption" Class="mr-4">@FormatSize(_selectedItem.Size)</MudText>
                        <MudTooltip Text="Copy URL">
                            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" OnClick="@(() => CopyToClipboard(_selectedItem.Url))" />
                        </MudTooltip>
                        <MudTooltip Text="Delete">
                            <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="@(() => DeleteFile(_selectedItem))" />
                        </MudTooltip>
                        <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="ClearSelection" />
                    </div>

                    <MudDivider Class="mb-4" />

                    <div class="flex-grow-1 overflow-auto">
                        @if (IsImage(_selectedItem.Name))
                        {
                            <MudImage Src="@_selectedItem.Url" Fluid="true" Class="rounded-lg" Style="max-height: 500px;" />
                        }
                        else if (IsText(_selectedItem.Name))
                        {
                            @if (_loadingContent)
                            {
                                <MudProgressCircular Indeterminate="true" />
                            }
                            else
                            {
                                <MudTextField Value="@_fileContent" Lines="20" ReadOnly="true" Variant="Variant.Outlined" Style="font-family: monospace;" />
                            }
                        }
                        else
                        {
                            <MudAlert Severity="Severity.Info">Preview not available for this file type.</MudAlert>
                        }
                    </div>
                }
                else
                {
                    <!-- Folder Gallery (Root or Subfolder) -->
                    @if (_currentFiles.Count == 0)
                    {
                        <div class="d-flex flex-column align-center justify-center flex-grow-1">
                            <MudIcon Icon="@Icons.Material.Filled.FolderOpen" Size="Size.Large" Color="Color.Default" Style="font-size: 5rem; opacity: 0.5;" />
                            <MudText Color="Color.Secondary" Class="mt-4">Empty Folder</MudText>
                        </div>
                    }
                    else
                    {
                        <MudGrid>
                            @foreach (var file in _currentFiles)
                            {
                                <MudItem xs="6" sm="4" md="3">
                                    <MudCard Class="cursor-pointer hover-card" @onclick="@(() => OnFileCardClick(file))" Elevation="1">
                                        @if (IsImage(file.Name))
                                        {
                                            <MudCardMedia Image="@file.Url" Height="140" />
                                        }
                                        else if (file.IsFolder)
                                        {
                                            <div class="d-flex align-center justify-center bg-light" style="height: 140px; background-color: #f5f5f5;">
                                                <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Large" Color="Color.Warning" Style="font-size: 4rem;" />
                                            </div>
                                        }
                                        else
                                        {
                                            <div class="d-flex align-center justify-center bg-light" style="height: 140px; background-color: #f5f5f5;">
                                                <MudIcon Icon="@Icons.Material.Filled.InsertDriveFile" Size="Size.Large" Color="Color.Default" />
                                            </div>
                                        }
                                        <MudCardContent Class="py-2">
                                            <MudText Typo="Typo.body2" Class="text-truncate">@file.Name</MudText>
                                        </MudCardContent>
                                    </MudCard>
                                </MudItem>
                            }
                        </MudGrid>
                    }
                }
            </MudPaper>
        </MudItem>
    </MudGrid>

</MudContainer>

<script>
    window.clipboardCopy = {
        copyText: function(text) {
            navigator.clipboard.writeText(text);
        }
    };
</script>

@code {
    private bool _loading = true;
    private bool _loadingContent = false;
    private HashSet<TreeItemData<FileTreeItem>> _treeItems = new();
    private List<FileTreeItem> _currentFiles = new(); 
    private FileTreeItem? _selectedItem;
    private FileTreeItem? _selectedFolder;
    private string _fileContent = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadFiles();
    }

    private async Task LoadFiles()
    {
        // Capture state
        var previouslySelectedPath = _selectedFolder?.FullPath;
        var expandedPaths = GetExpandedPaths(_treeItems);

        _loading = true;
        try
        {
            var dtos = await StorageClient.GetFilesAsync();
            BuildTree(dtos);
            
            // Restore state
            RestoreExpandedState(_treeItems, expandedPaths);

            // Restore selection or default to Root
            if (previouslySelectedPath != null)
            {
                 var node = FindNodeRecursive(_treeItems, previouslySelectedPath);
                 if (node != null && node.Value?.IsFolder == true)
                 {
                     _selectedFolder = node.Value;
                     // We need to pass the TreeItemData to UpdateCurrentFiles
                     UpdateCurrentFiles(node);
                 }
                 else
                 {
                     _selectedFolder = null;
                     UpdateCurrentFiles(null);
                 }
            }
            else
            {
                _selectedFolder = null;
                UpdateCurrentFiles(null);
            }
            UpdateBreadcrumbs();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load files: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private HashSet<string> GetExpandedPaths(IEnumerable<TreeItemData<FileTreeItem>> items)
    {
        var paths = new HashSet<string>();
        if (items == null) return paths;

        foreach (var item in items)
        {
            if (item.Expanded && item.Value != null)
            {
                paths.Add(item.Value.FullPath);
            }
            if (item.Children != null)
            {
                paths.UnionWith(GetExpandedPaths(item.Children));
            }
        }
        return paths;
    }

    private void RestoreExpandedState(IEnumerable<TreeItemData<FileTreeItem>> items, HashSet<string> expandedPaths)
    {
        if (items == null) return;

        foreach (var item in items)
        {
            if (item.Value != null && expandedPaths.Contains(item.Value.FullPath))
            {
                item.Expanded = true;
            }
            if (item.Children != null)
            {
                RestoreExpandedState(item.Children, expandedPaths);
            }
        }
    }

    // Tree Construction
    private void BuildTree(List<StorageFileDto> files)
    {
        var rootItems = new HashSet<TreeItemData<FileTreeItem>>();

        // Helper to find existing node in a collection
        TreeItemData<FileTreeItem>? FindNode(ICollection<TreeItemData<FileTreeItem>>? collection, string text)
        {
            if (collection == null) return null;
            foreach (var item in collection)
            {
                if (item.Text == text) return item;
            }
            return null;
        }

        foreach (var file in files)
        {
            var parts = file.Name.Split('/', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length == 0) continue;

            ICollection<TreeItemData<FileTreeItem>> currentLevel = rootItems;
            TreeItemData<FileTreeItem>? parent = null;

            for (int i = 0; i < parts.Length; i++)
            {
                var part = parts[i];
                // It is a file only if it's the last part AND the original path didn't end with /
                var isFile = (i == parts.Length - 1) && !file.Name.EndsWith("/");
                
                // Skip .keep files from tree
                if (isFile && part == ".keep") 
                {
                    // But we still traversed parents so they are created.
                    continue; 
                }
                
                var existing = FindNode(currentLevel, part);

                if (existing == null)
                {
                    var fileItem = new FileTreeItem
                    {
                        Name = part,
                        FullPath = isFile ? file.Name : (string.Join("/", parts.Take(i + 1)) + "/"), // Reconstruct path for folders
                        IsFolder = !isFile,
                        Size = isFile ? file.Size : 0,
                        Url = isFile ? file.Url : string.Empty,
                    };

                    // Correction: For intermediate folders inferred from file paths (e.g. A/B/file.txt -> A and B are folders)
                    // their FullPath might not be explicitly in 'files' list. 
                    // But we construct consistent path: "A/" then "A/B/"
                    
                    existing = new TreeItemData<FileTreeItem>
                    {
                        Text = part,
                        Value = fileItem,
                        Icon = !isFile ? Icons.Material.Filled.Folder : Icons.Material.Filled.InsertDriveFile,
                        Expanded = isFile ? false : false // Default collapsed
                    };

                    if (currentLevel is HashSet<TreeItemData<FileTreeItem>> hashSet)
                    {
                        hashSet.Add(existing);
                    }
                    else if (currentLevel is List<TreeItemData<FileTreeItem>> list)
                    {
                        list.Add(existing);
                    }
                }

                if (!isFile || existing.Value?.IsFolder == true) // If it's a folder (explicit or implicit)
                {
                    if (existing.Children == null) existing.Children = new List<TreeItemData<FileTreeItem>>();
                    currentLevel = existing.Children;
                    parent = existing;
                }
            }
        }
        _treeItems = rootItems;
    }

    private async Task OnTreeItemClick(TreeItemData<FileTreeItem> itemData)
    {
        var item = itemData.Value;
        if (item == null) return;

        if (item.IsFolder)
        {
            _selectedFolder = item;
            _selectedItem = null;
            UpdateCurrentFiles(itemData);
            UpdateBreadcrumbs();
            // Toggle expansion handled by binding
        }
        else
        {
            _selectedItem = item;
            await LoadFilePreview(item);
        }
    }

    private async Task OnFileCardClick(FileTreeItem item)
    {
        if (item.IsFolder)
        {
            // Find the node in the tree to select it
            var node = FindNodeRecursive(_treeItems, item.FullPath);
            if (node != null)
            {
                // Expand parent if needed? It should be already expanded if we see the child.
                // Select the folder
                await OnTreeItemClick(node);
            }
        }
        else
        {
            _selectedItem = item;
            await LoadFilePreview(item);
        }
    }

    private void UpdateCurrentFiles(TreeItemData<FileTreeItem>? folderData)
    {
        if (folderData == null)
        {
             // Root: All items at root
             _currentFiles = _treeItems
                .Where(x => x.Value != null)
                .Select(x => x.Value!)
                .OrderByDescending(x => x.IsFolder)
                .ThenBy(x => x.Name)
                .ToList();
        }
        else
        {
             if (folderData.Children != null)
             {
                 _currentFiles = folderData.Children
                    .Where(x => x.Value != null)
                    .Select(x => x.Value!)
                    .OrderByDescending(x => x.IsFolder)
                    .ThenBy(x => x.Name)
                    .ToList();
             }
             else
             {
                 _currentFiles = new List<FileTreeItem>();
             }
        }
        
        StateHasChanged();
    }

    private async Task LoadFilePreview(FileTreeItem item)
    {
        if (IsText(item.Name))
        {
            _loadingContent = true;
            try
            {
                _fileContent = await StorageClient.GetFileContentAsync(item.FullPath);
            }
            catch
            {
                _fileContent = "Error loading content.";
            }
            finally
            {
                _loadingContent = false;
            }
        }
    }

    private void ClearSelection()
    {
        _selectedItem = null;
    }

    private async Task CreateFolder()
    {
        var parameters = new DialogParameters { ["Label"] = "Folder Name", ["Value"] = "New Folder" };
        var dialog = await DialogService.ShowAsync<PromptDialog>("Create Folder", parameters);
        var result = await dialog.Result;

        if (!result.Canceled && !string.IsNullOrWhiteSpace(result.Data as string))
        {
            var folderName = (string)result.Data;
            try
            {
                 string? parent = _selectedFolder?.FullPath;
                 await StorageClient.CreateFolderAsync(folderName, parent);
                 Snackbar.Add("Folder created", Severity.Success);
                 await LoadFiles();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task UploadFiles(IBrowserFile file)
    {
        _loading = true; 
        try
        {
            await StorageClient.UploadFileAsync(file);
            Snackbar.Add("Uploaded!", Severity.Success);
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally { _loading = false; }
    }

    private async Task DeleteFile(FileTreeItem item)
    {
         var confirm = await DialogService.ShowMessageBox("Delete", $"Delete {item.Name}?", yesText: "Yes", cancelText: "No");
         if (confirm == true)
         {
             await StorageClient.DeleteFileAsync(item.FullPath);
             Snackbar.Add("Deleted", Severity.Success);
             _selectedItem = null;
             await LoadFiles();
         }
    }
    
    private async Task CopyToClipboard(string text)
    {
        await JSRuntime.InvokeVoidAsync("clipboardCopy.copyText", text);
        Snackbar.Add("Copied!", Severity.Success);
    }



    private static bool IsImage(string name)
    {
        var ext = System.IO.Path.GetExtension(name).ToLower();
        return new[] { ".png", ".jpg", ".jpeg", ".gif", ".webp" }.Contains(ext);
    }

    private static bool IsText(string name)
    {
        var ext = System.IO.Path.GetExtension(name).ToLower();
        return new[] { ".txt", ".md", ".json", ".xml", ".css", ".js", ".cs", ".html" }.Contains(ext);
    }

    private static string FormatSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private List<BreadcrumbLink> _breadcrumbLinks = new();

    private void OnBreadcrumbClick(string? path)
    {
        if (string.IsNullOrEmpty(path))
        {
            // Root
            _selectedFolder = null;
            UpdateCurrentFiles(null);
            return;
        }

        // Find the node corresponding to path
        var node = FindNodeRecursive(_treeItems, path);
        if (node != null)
        {
             OnTreeItemClick(node); // Reuse logic
        }
    }

    private void UpdateBreadcrumbs()
    {
        _breadcrumbLinks.Clear();
        if (_selectedFolder != null)
        {
            var parts = _selectedFolder.FullPath.Split('/');
            string currentPath = "";
            foreach (var part in parts)
            {
                if (string.IsNullOrEmpty(currentPath)) currentPath = part;
                else currentPath += "/" + part;
                
                _breadcrumbLinks.Add(new BreadcrumbLink(part, currentPath));
            }
        }
    }
    
    // Helper to find node recursively
    private TreeItemData<FileTreeItem>? FindNodeRecursive(ICollection<TreeItemData<FileTreeItem>>? collection, string fullPath)
    {
        if (collection == null) return null;
        foreach (var item in collection)
        {
            if (item.Value?.FullPath == fullPath) return item;
            var childResult = FindNodeRecursive(item.Children, fullPath);
            if (childResult != null) return childResult;
        }
        return null;
    }

    public record BreadcrumbLink(string Name, string Path);

    public class FileTreeItem
    {
        public string Name { get; set; } = string.Empty;
        public string FullPath { get; set; } = string.Empty;
        public bool IsFolder { get; set; }
        public long Size { get; set; }
        public string Url { get; set; } = string.Empty;
        
        public override bool Equals(object? obj) => obj is FileTreeItem other && FullPath == other.FullPath;
        public override int GetHashCode() => FullPath.GetHashCode();
    }
}
